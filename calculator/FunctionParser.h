/****************************************************************************
**
** FunctionParser.h
** «аголовочный файл, в котором находитс€ класс дл€ преобразовани€ выражени€
** из инфиксной записи в обратную польскую запись.
**
** »змен€ть данный класс не рекомендуетс€ в цел€х сохранени€ корректной
** обработки данных.
**
****************************************************************************/


#ifndef FUNCTIONPARSER_H
#define FUNCTIONPARSER_H

#include <string>
#include <vector>
#include <stack>
#include "StringTokenizer.h"
#include <algorithm>
#include <locale>
using namespace std;

class FunctionParser
{
private:
	string _expression;
	string _delims = "() +-*/^";
	vector<string> * _parsedExpression;

	vector<string> * _functions;
	locale _loc{"Russian_Russia"};

	bool _flag;

	////////////////////////////////////////////////////////////
	/// \brief ѕровер€ет, €вл€етс€ ли токен оператором
	///
	/// \param token - токен строки
	///
	/// \return true, если токен €вл€етс€ оператором
	///         false, если токен таковым не €вл€етс€
	///
	////////////////////////////////////////////////////////////
	bool isOperation(const string & token) const;

	////////////////////////////////////////////////////////////
	/// \brief ¬озвращает приоритет оператора в условных
	///        единицах
	///
	/// \param operation - токен строки с оператором
	///
	/// \return условна€ единица, обозначающа€ приоритет
	///         оператора
	///
	////////////////////////////////////////////////////////////
	int getValueOfOperation(const string & operation);

	////////////////////////////////////////////////////////////
	/// \brief ѕровер€ет принадлежит ли токен к какой-либо
	///        функции
	///
	/// \param token - токен строки
	///
	/// \return true, если токен €вл€етс€ матем. функцией
	///         false, если токен таковой не €вл€етс€
	///
	////////////////////////////////////////////////////////////
	bool isFunction(const string & token) const;

	bool isDelimiter(const string & token);

	bool isWord(const string & token) const;

	bool isNumber(const string & token) const;
public:
	//—оздание объекта обработчика выражени€
	FunctionParser();
	~FunctionParser();

	explicit FunctionParser(const vector<string> & functions, const string & expression = string());

	////////////////////////////////////////////////////////////
	/// \brief ”станавливает новое выражение дл€ обработки
	///
	/// \param expression - выражение в инфикной форме
	///
	////////////////////////////////////////////////////////////
	void setExpression(const string & expression);

	////////////////////////////////////////////////////////////
	/// \brief ¬озвращает выражение дл€ обработки
	///
	/// \return exression - строка с выражением
	///
	////////////////////////////////////////////////////////////
	string getExpression() const;

	////////////////////////////////////////////////////////////
	/// \brief возвращает массив строк, в котором содержитс€
	///         преобразованное выражение
	///
	/// \return если преобразований выражений не проводилось,
	///         или выражение содержало ошибки,то вернетс€
	///         пустой массив. »наче вернетс€ заполненный массив
	///
	////////////////////////////////////////////////////////////
	vector<string> & getParsedExpression() const;

	////////////////////////////////////////////////////////////
	/// \brief ќбрабатывает expression (выражение)
	///
	////////////////////////////////////////////////////////////
	bool parseExpression();
};

#endif // FUNCTIONPARSER_H
